function [BinWinSec, BinTrcksLR, BinTrcksSR, BinTrcksO, BinTrcksLRstate, BinTrcksSRstate, ...            BinTrcksOstate, BinTrcksShallowO, BinTrcksShallowOstate, BinTrcksDeepO, BinTrcksDeepOstate, ...            BinTrcksRevO, BinTrcksRevOstate, BinTrcksRevShallow, BinTrcksRevShallowState, BinTrcksPir, ...            BinTrcksPirState, t] = ...            ShallowDeepOTalsV4_MSv107_IH_woPir(sParam, Tracks, BinWin, SampleRate, calcState)                %-- this function does not return unbinned data for the purpose of better%-- memory performance%-- in addition it uses reshape for databinning%-- generates data arrays of reversal and omega and speed data from Worm Analyzer%-- 'Analyze All Tracks' function. %-- Reads Tracks structure and returns data arrays with each row corresponding to one track and each column to one frame or bin%-- NaN if no track at given frame, RingDistance <=RingLimit or tracklength <= BinWin%-- BinWin: Number of frames for each bin%-- 0 if no event, 1/>1 number of reversal initiation events in fram/bin,%% (c) Michael Sonntagdisp(strcat('... running ', 32, mfilename, ', calculating turn/reversal matrices'));%-- Process Pirouettes Data%-- -----------------------Len = max([Tracks.Frames]);BinNum = floor(Len / BinWin);BinWinSec = BinWin / SampleRate;     t = (BinWinSec / 2 : BinWinSec : BinWinSec * BinNum - (BinWinSec / 2)); %-- time(seconds)bintrcknum = zeros(1, BinNum);if BinWin > 1    disp('... Warning: behavioral state is only set when turn binning = 1');end;BinTrcksLR = (NaN(length(Tracks), BinNum, 'single')); %-- create data arrays for binned data; initiation eventsBinTrcksSR = (NaN(length(Tracks), BinNum, 'single'));BinTrcksO = (NaN(length(Tracks), BinNum, 'single'));BinTrcksShallowO = (NaN(length(Tracks), BinNum, 'single'));BinTrcksDeepO = (NaN(length(Tracks), BinNum, 'single'));BinTrcksRevO = (NaN(length(Tracks), BinNum, 'single'));BinTrcksRevShallow = (NaN(length(Tracks), BinNum, 'single'));BinTrcksPir = (NaN(length(Tracks), BinNum, 'single'));BinTrcksLRstate = [];BinTrcksSRstate = [];BinTrcksOstate = [];BinTrcksShallowOstate = [];BinTrcksDeepOstate = [];BinTrcksRevOstate = [];BinTrcksRevShallowState = [];BinTrcksPirState = [];%-- calculate state only if there is sufficient memoryif calcState    BinTrcksLRstate = (NaN(length(Tracks), BinNum, 'single')); %-- create data arrays for binned data; state    BinTrcksSRstate = (NaN(length(Tracks), BinNum, 'single'));    BinTrcksOstate = (NaN(length(Tracks), BinNum, 'single'));    BinTrcksShallowOstate = (NaN(length(Tracks), BinNum, 'single'));    BinTrcksDeepOstate = (NaN(length(Tracks), BinNum, 'single'));    BinTrcksRevOstate = (NaN(length(Tracks), BinNum, 'single'));    BinTrcksRevShallowState = (NaN(length(Tracks), BinNum, 'single'));    BinTrcksPirState = (NaN(length(Tracks), BinNum, 'single'));end;for i = 1 : length(Tracks)    if Tracks(i).Analyzed && Tracks(i).NumFrames >= BinWin        trcksLR = (NaN(1, Len, 'single')); %-- create data arrays for raw data; initiation events        trcksSR = (NaN(1, Len, 'single'));        trcksO = (NaN(1, Len, 'single'));        trcksShallowO = (NaN(1, Len, 'single'));        trcksDeepO = (NaN(1, Len, 'single'));        trcksRevO = (NaN(1, Len, 'single'));        trcksRevShallow = (NaN(1, Len, 'single'));        trcksPir = (NaN(1, Len, 'single'));        if calcState            trcksLRstate = (NaN(1, Len, 'single')); %-- create data arrays for raw data; state            trcksSRstate = (NaN(1, Len, 'single'));            trcksOstate = (NaN(1, Len, 'single'));            trcksShallowOstate = (NaN(1, Len, 'single'));            trcksDeepOstate = (NaN(1, Len, 'single'));            trcksRevOstate = (NaN(1, Len, 'single'));            trcksRevShallowState = (NaN(1, Len, 'single'));            trcksPirState = (NaN(1, Len, 'single'));        end;        Reversals = Tracks(i).polishedReversals;        Omegas = Tracks(i).OmegaTrans;%         ShallowOmegas = Tracks(i).OmegaTransShallow;%         DeepOmegas = Tracks(i).OmegaTransDeep;%         RevOmegas = Tracks(i).ReverseOmega;%         RevShallow = Tracks(i).ReverseShallowTurn;%         Pirouettes = Tracks(i).Pirouettes;        trcksLR(Tracks(i).Frames) = 0; %-- when track set to 0        trcksSR(Tracks(i).Frames) = 0;        trcksO(Tracks(i).Frames) = 0;        trcksShallowO(Tracks(i).Frames) = 0;        trcksDeepO(Tracks(i).Frames) = 0;        trcksRevO(Tracks(i).Frames) = 0;        trcksRevShallow(Tracks(i).Frames) = 0;        trcksPir(Tracks(i).Frames) = 0;        if calcState            trcksLRstate(Tracks(i).Frames) = 0; %-- when track set to 0            trcksSRstate(Tracks(i).Frames) = 0;            trcksOstate(Tracks(i).Frames) = 0;            trcksShallowOstate(Tracks(i).Frames) = 0;            trcksDeepOstate(Tracks(i).Frames) = 0;            trcksRevOstate(Tracks(i).Frames) = 0;            trcksRevShallowState(Tracks(i).Frames) = 0;            trcksPirState(Tracks(i).Frames) = 0;        end;        %-- find track parts close to the copper ring to exclude behavior attributed to this        %-- in wormtracker RingDistance is recorded every 4th frame%         RingD = find(Tracks(i).RingDistance <= sParam.ROalsRingLimit & Tracks(i).RingDistance >0);%         RingD = [RingD RingD-1 RingD-2 RingD-3];%         RingD = RingD(RingD > 0);        %-- all pirouettes%         if ~isempty(Pirouettes)%             trcksPir(Tracks(i).Frames(Pirouettes(:,1))) = 1; %-- when O initiation set to 1%             %-- remove data while animals are close to copper ring%             trcksPir(Tracks(i).Frames(RingD)) = NaN;% %             if calcState%                 for pirs = 1 : size(Pirouettes,1)%                     trcksPirState(Tracks(i).Frames(Pirouettes(pirs,1)) : Tracks(i).Frames(Pirouettes(pirs,2))) = 1; %-- during O set to 1%                 end;%                 trcksPirState(Tracks(i).Frames(RingD)) = NaN;%             end;%         end;                if ~isempty(Reversals)            %-- Collect all Reversal Initiation Events and set behavioral state            LongRevI = find(Tracks(i).polishedReversals(:,4) == 2);            ShortRevI = find(Tracks(i).polishedReversals(:,4) <= 1); % edited 0 or 1 -> reversal            trcksLR(Tracks(i).Frames(Reversals(LongRevI,1))) = 1; %-- when LR initiation set to 1            trcksSR(Tracks(i).Frames(Reversals(ShortRevI,1))) = 1; %-- when SR initiation set to 1            %-- remove Reversals and speed data while animals are close to copper ring%             trcksLR(Tracks(i).Frames(RingD)) = NaN; %-- set to NaN if close to Ring%             trcksSR(Tracks(i).Frames(RingD)) = NaN;%                         if calcState                for lri = 1 : size(LongRevI)                    %-- during LR state set to 1                    trcksLRstate(Tracks(i).Frames(Reversals(LongRevI(lri),1)) : Tracks(i).Frames(Reversals(LongRevI(lri),2))) = 1;                end;                for sri = 1 : size(ShortRevI)                    %-- during SR  set to 1                    trcksSRstate(Tracks(i).Frames(Reversals(ShortRevI(sri),1)) : Tracks(i).Frames(Reversals(ShortRevI(sri),2))) = 1;                end;%                 trcksLRstate(Tracks(i).Frames(RingD)) = NaN; %-- set to NaN if close to Ring%                 trcksSRstate(Tracks(i).Frames(RingD)) = NaN;            end;        end;        %-- all omegas        if ~isempty(Omegas)            trcksO(Tracks(i).Frames(Omegas(:,1))) = 1; %-- when O initiation set to 1            %-- remove turns and speed data while animals are close to copper ring%             trcksO(Tracks(i).Frames(RingD)) = NaN;            if calcState                for omgs = 1 : size(Omegas,1)                    trcksOstate(Tracks(i).Frames(Omegas(omgs,1)) : Tracks(i).Frames(Omegas(omgs,2))) = 1; %-- during O set to 1                end;%                 trcksOstate(Tracks(i).Frames(RingD)) = NaN;            end;        end;                    %-- shallow turns%         if ~isempty(ShallowOmegas)% %             trcksShallowO(Tracks(i).Frames(ShallowOmegas(:,1))) = 1; %-- when O initiation set to 1%             trcksShallowO(Tracks(i).Frames(RingD)) = NaN;% %             if calcState%                 for somgs = 1 : size(ShallowOmegas,1)%                     trcksShallowOstate(Tracks(i).Frames(ShallowOmegas(somgs,1)) : Tracks(i).Frames(ShallowOmegas(somgs,2))) = 1; %-- during O set to 1%                 end;%                 trcksShallowOstate(Tracks(i).Frames(RingD)) = NaN;%             end;%         end;% %         %-- deep omegas%         if ~isempty(DeepOmegas)%             trcksDeepO(Tracks(i).Frames(DeepOmegas(:,1))) = 1; %-- when O initiation set to 1%             trcksDeepO(Tracks(i).Frames(RingD)) = NaN;% %             if calcState%                 for domgs = 1 : size(DeepOmegas,1)%                     trcksDeepOstate(Tracks(i).Frames(DeepOmegas(domgs,1)) : Tracks(i).Frames(DeepOmegas(domgs,2))) = 1; %-- during O set to 1%                 end;%                 trcksDeepOstate(Tracks(i).Frames(RingD)) = NaN;%             end;%         end;% %         %-- reverse deep omegas%         if ~isempty(RevOmegas)%             trcksRevO(Tracks(i).Frames(RevOmegas(:,1))) = 1; %-- when O initiation set to 1%             trcksRevO(Tracks(i).Frames(RingD)) = NaN;%             %             if calcState%                 for romgs = 1 : size(RevOmegas,1)%                     trcksRevOstate(Tracks(i).Frames(RevOmegas(romgs,1)) : Tracks(i).Frames(RevOmegas(romgs,2))) = 1; %-- during O set to 1%                 end;%                 trcksRevOstate(Tracks(i).Frames(RingD)) = NaN;%             end;%         end;% %         %-- reverse shallow turns%         if ~isempty(RevShallow)%             trcksRevShallow(Tracks(i).Frames(RevShallow(:,1))) = 1; %-- when O initiation set to 1%             trcksRevShallow(Tracks(i).Frames(RingD)) = NaN;%             if calcState%                 for romgs = 1 : size(RevShallow,1)%                     trcksRevShallowState(Tracks(i).Frames(RevShallow(romgs,1)) : Tracks(i).Frames(RevShallow(romgs,2))) = 1; %-- during O set to 1%                 end;%                 trcksRevShallowState(Tracks(i).Frames(RingD)) = NaN;%             end;%         end;%                 %-- bin data        if BinWin == 1            BinTrcksLR(i,:) = trcksLR;            BinTrcksSR(i,:) = trcksSR;            BinTrcksO(i,:) = trcksO;            BinTrcksShallowO(i,:) = trcksShallowO;            BinTrcksDeepO(i,:) = trcksDeepO;            BinTrcksRevO(i,:) = trcksRevO;            BinTrcksRevShallow(i,:) = trcksRevShallow;            BinTrcksPir(i,:) = trcksPir;                        if calcState                BinTrcksLRstate(i,:) = trcksLRstate;                BinTrcksSRstate(i,:) = trcksSRstate;                BinTrcksOstate(i,:) = trcksOstate;                BinTrcksShallowOstate(i,:) = trcksShallowOstate;                BinTrcksDeepOstate(i,:) = trcksDeepOstate;                BinTrcksRevOstate(i,:) = trcksRevOstate;                BinTrcksRevShallowState(i,:) = trcksRevShallowState;                BinTrcksPirState(i,:) = trcksPirState;            end;        else            BinTrcksLR(i,:) = sum(reshape(trcksLR(1 : BinNum * BinWin), BinWin, BinNum));            BinTrcksSR(i,:) = sum(reshape(trcksSR(1: BinNum * BinWin), BinWin, BinNum));            BinTrcksO(i,:) = sum(reshape(trcksO(1: BinNum * BinWin), BinWin, BinNum));            BinTrcksShallowO(i,:) = sum(reshape(trcksShallowO(1: BinNum * BinWin), BinWin, BinNum));            BinTrcksDeepO(i,:) = sum(reshape(trcksDeepO(1: BinNum * BinWin), BinWin, BinNum));            BinTrcksRevO(i,:) = sum(reshape(trcksRevO(1: BinNum * BinWin), BinWin, BinNum));            BinTrcksRevShallow(i,:) = sum(reshape(trcksRevShallow(1: BinNum * BinWin), BinWin, BinNum));            BinTrcksPir(i,:) = sum(reshape(trcksPir(1: BinNum * BinWin), BinWin, BinNum));        end;    end;end;